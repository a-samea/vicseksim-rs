//! # Ensemble IO Module - Ensemble Data Persistence
//!
//! This module handles saving and loading of ensemble data generated by the ensemble module.
//! Ensembles are saved as binary files using serde serialization in the `./data/ensemble/` directory.
//!
//! ## File Format
//!
//! - **Location**: `./data/ensemble/[tag].bin`
//! - **Format**: Binary serialized data using bincode
//! - **Content**: `EnsembleData` struct containing birds and metadata
//!
//! ## Usage
//!
//! ```rust
//! use std::sync::mpsc;
//! use flocking_lib::io::ensemble;
//!
//! // Setup channel to receive ensemble from generation
//! let (tx, rx) = mpsc::channel();
//!
//! // Start ensemble receiver
//! let  _ = ensemble::start_receiver(rx, "my_ensemble".to_string(), 1.0, 1.0, 0.1);
//! ```

use crate::bird::Bird;
use serde::{Deserialize, Serialize};
use std::fs::{self, File};
use std::io::{BufReader, BufWriter};
use std::path::{Path, PathBuf};
use std::sync::mpsc;
use std::time::{SystemTime, UNIX_EPOCH};

/// Ensemble data structure containing birds and metadata
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct EnsembleData {
    /// Vector of birds in the ensemble
    pub birds: Vec<Bird>,
    /// Metadata about the ensemble
    pub metadata: EnsembleMetadata,
}

/// Metadata associated with each ensemble
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct EnsembleMetadata {
    /// User-defined tag for the ensemble
    pub tag: String,
    /// Number of birds in the ensemble
    pub num_birds: usize,
    /// Sphere radius used for generation
    pub radius: f64,
    /// Speed of all birds
    pub speed: f64,
    /// Minimum distance constraint used during generation
    pub min_distance: f64,
    /// Timestamp when ensemble was created
    pub created_at: u64,
    /// File format version for compatibility
    pub version: String,
}

/// Status of an ensemble file
#[derive(Debug, Clone)]
pub struct EnsembleStatus {
    /// File path
    pub path: PathBuf,
    /// Whether the file is valid and loadable
    pub is_valid: bool,
    /// Error message if invalid
    pub error: Option<String>,
    /// Metadata if valid
    pub metadata: Option<EnsembleMetadata>,
}

/// Starts a receiver thread that listens for ensemble data from MPSC channel
/// and saves it to disk with the specified tag
///
/// # Arguments
///
/// * `rx` - MPSC receiver channel for ensemble data
/// * `tag` - Tag name for the ensemble file
/// * `radius` - Sphere radius used for generation
/// * `speed` - Speed of birds
/// * `min_distance` - Minimum distance constraint
pub fn start_receiver(
    rx: mpsc::Receiver<Vec<Bird>>,
    tag: String,
    radius: f64,
    speed: f64,
    min_distance: f64,
) -> Result<(), Box<dyn std::error::Error>> {
    // Ensure ensemble directory exists
    crate::io::ensure_data_directories()?;

    // Receive ensemble data
    let birds = rx.recv()?;

    // Create metadata
    let metadata = EnsembleMetadata {
        tag: tag.clone(),
        num_birds: birds.len(),
        radius,
        speed,
        min_distance,
        created_at: SystemTime::now().duration_since(UNIX_EPOCH)?.as_secs(),
        version: env!("CARGO_PKG_VERSION").to_string(),
    };

    // Create ensemble data
    let ensemble_data = EnsembleData { birds, metadata };

    // Save to file
    save_ensemble(&ensemble_data, &tag)?;

    println!(
        "Ensemble '{}' saved successfully with {} birds",
        tag,
        ensemble_data.birds.len()
    );

    Ok(())
}

/// Saves ensemble data to a binary file
///
/// # Arguments
///
/// * `ensemble` - The ensemble data to save
/// * `tag` - Tag name for the file
pub fn save_ensemble(ensemble: &EnsembleData, tag: &str) -> Result<(), Box<dyn std::error::Error>> {
    let file_path = get_ensemble_path(tag);

    // Create parent directory if it doesn't exist
    if let Some(parent) = file_path.parent() {
        fs::create_dir_all(parent)?;
    }

    let file = File::create(&file_path)?;
    let writer = BufWriter::new(file);

    bincode::serialize_into(writer, ensemble)?;

    Ok(())
}

/// Loads ensemble data from a binary file
///
/// # Arguments
///
/// * `tag` - Tag name of the ensemble to load
pub fn load_ensemble(tag: &str) -> Result<EnsembleData, Box<dyn std::error::Error>> {
    let file_path = get_ensemble_path(tag);

    if !file_path.exists() {
        return Err(format!("Ensemble file not found: {}", file_path.display()).into());
    }

    let file = File::open(&file_path)?;
    let reader = BufReader::new(file);

    let ensemble: EnsembleData = bincode::deserialize_from(reader)?;

    Ok(ensemble)
}

/// Enumerates all ensemble files and verifies their status
pub fn enumerate_ensembles() -> Result<Vec<EnsembleStatus>, Box<dyn std::error::Error>> {
    let ensemble_dir = Path::new("./data/ensemble");

    if !ensemble_dir.exists() {
        return Ok(Vec::new());
    }

    let mut statuses = Vec::new();

    for entry in fs::read_dir(ensemble_dir)? {
        let entry = entry?;
        let path = entry.path();

        if path.extension().and_then(|s| s.to_str()) == Some("bin") {
            let status = verify_ensemble_file(&path);
            statuses.push(status);
        }
    }

    // Sort by creation time (newest first)
    statuses.sort_by(|a, b| match (&a.metadata, &b.metadata) {
        (Some(meta_a), Some(meta_b)) => meta_b.created_at.cmp(&meta_a.created_at),
        (Some(_), None) => std::cmp::Ordering::Less,
        (None, Some(_)) => std::cmp::Ordering::Greater,
        (None, None) => a.path.cmp(&b.path),
    });

    Ok(statuses)
}

/// Verifies the status of an ensemble file
fn verify_ensemble_file(path: &Path) -> EnsembleStatus {
    match load_ensemble_from_path(path) {
        Ok(ensemble) => EnsembleStatus {
            path: path.to_path_buf(),
            is_valid: true,
            error: None,
            metadata: Some(ensemble.metadata),
        },
        Err(e) => EnsembleStatus {
            path: path.to_path_buf(),
            is_valid: false,
            error: Some(e.to_string()),
            metadata: None,
        },
    }
}

/// Loads ensemble data from a specific file path
fn load_ensemble_from_path(path: &Path) -> Result<EnsembleData, Box<dyn std::error::Error>> {
    let file = File::open(path)?;
    let reader = BufReader::new(file);
    let ensemble: EnsembleData = bincode::deserialize_from(reader)?;
    Ok(ensemble)
}

/// Gets the file path for an ensemble with the given tag
fn get_ensemble_path(tag: &str) -> PathBuf {
    Path::new("./data/ensemble").join(format!("{}.bin", tag))
}

/// Lists all available ensemble tags
pub fn list_ensemble_tags() -> Result<Vec<String>, Box<dyn std::error::Error>> {
    let statuses = enumerate_ensembles()?;
    let tags: Vec<String> = statuses
        .into_iter()
        .filter_map(|status| {
            if status.is_valid {
                status.metadata.map(|meta| meta.tag)
            } else {
                None
            }
        })
        .collect();

    Ok(tags)
}
