//! # Ensemble IO Module - Ensemble Data Persistence
//!
//! This module handles saving and loading of ensemble data generated by the ensemble module.
//! Ensembles are saved as binary files using serde serialization in the `./data/ensemble/` directory.
//!
//! ## File Format
//!
//! - **Location**: `./data/ensemble/[tag].bin`
//! - **Format**: Binary serialized data using bincode
//! - **Content**: `EnsembleData` struct containing birds and metadata
//!
//! ## Usage
//!
//! ```rust
//! use std::sync::mpsc;
//! use flocking_lib::io::ensemble;
//!
//! // Setup channel to receive ensemble from generation
//! let (tx, rx) = mpsc::channel();
//!
//! // Start ensemble receiver that handles EnsembleResult from ensemble module
//! let handle = ensemble::start_receiver_thread(rx);
//! ```

use crate::bird::Bird;
use serde::{Deserialize, Serialize};
use std::fs::{self, File};
use std::io::{BufReader, BufWriter};
use std::path::{Path, PathBuf};
use std::sync::mpsc;
use std::thread;
use std::time::{SystemTime, UNIX_EPOCH};


/// Status of an ensemble file
#[derive(Debug, Clone)]
pub struct EnsembleStatus {
    /// File path
    pub path: PathBuf,
    /// Whether the file is valid and loadable
    pub is_valid: bool,
    /// Error message if invalid
    pub error: Option<String>,
    /// Metadata if valid
    pub metadata: Option<EnsembleMetadata>,
}


/// Starts a receiver thread that listens for EnsembleResult from the ensemble module
/// and saves each ensemble to disk automatically
///
/// # Arguments
///
/// * `rx` - MPSC receiver channel for EnsembleResult data
///
/// # Returns
///
/// * A join handle for the spawned receiver thread
pub fn start_receiver_thread(
    rx: mpsc::Receiver<EnsembleResult>,
) -> thread::JoinHandle<Result<(), String>> {
    thread::spawn(move || {
        // Ensure ensemble directory exists
        crate::io::ensure_data_directories().map_err(|e| e.to_string())?;

        // Process each ensemble result as it arrives
        while let Ok(ensemble_result) = rx.recv() {
            // Add timestamp info
            let ensemble_with_metadata = EnsembleResult {
                created_at: SystemTime::now().duration_since(UNIX_EPOCH)
                    .map_err(|e| e.to_string())?.as_secs(),
                ..ensemble_result
            };

            // Save to file using the tag
            save_ensemble_result(&ensemble_with_metadata).map_err(|e| e.to_string())?;

            println!(
                "Ensemble '{}' (ID: {}) saved successfully with {} birds",
                ensemble_with_metadata.tag,
                ensemble_with_metadata.id,
                ensemble_with_metadata.birds.len()
            );
        }

        Ok(())
    })
}

/// Saves EnsembleResult data to a binary file
///
/// # Arguments
///
/// * `ensemble` - The ensemble result to save
pub fn save_ensemble_result(ensemble: &EnsembleResult) -> Result<(), Box<dyn std::error::Error>> {
    let file_path = get_ensemble_path(&ensemble.tag);

    // Create parent directory if it doesn't exist
    if let Some(parent) = file_path.parent() {
        fs::create_dir_all(parent)?;
    }

    let file = File::create(&file_path)?;
    let writer = BufWriter::new(file);

    bincode::serialize_into(writer, ensemble)?;

    Ok(())
}

/// Loads ensemble data as EnsembleResult from a binary file
///
/// # Arguments
///
/// * `tag` - Tag name of the ensemble to load
pub fn load_ensemble_result(tag: &str) -> Result<EnsembleResult, Box<dyn std::error::Error>> {
    let file_path = get_ensemble_path(tag);

    if !file_path.exists() {
        return Err(format!("Ensemble file not found: {}", file_path.display()).into());
    }

    let file = File::open(&file_path)?;
    let reader = BufReader::new(file);

    // Try loading as EnsembleResult first (new format)
    match bincode::deserialize_from::<_, EnsembleResult>(reader) {
        Ok(ensemble) => Ok(ensemble),
        Err(_) => {
            // Fallback: try loading as legacy EnsembleData and convert
            let file = File::open(&file_path)?;
            let reader = BufReader::new(file);
            let legacy_data: EnsembleData = bincode::deserialize_from(reader)?;
            
            // Convert legacy format to new format
            Ok(EnsembleResult {
                id: 0, // Legacy files don't have IDs
                tag: legacy_data.metadata.tag,
                birds: legacy_data.birds,
                params: EnsembleGenerationParams {
                    n_particles: legacy_data.metadata.num_birds,
                    radius: legacy_data.metadata.radius,
                    speed: legacy_data.metadata.speed,
                    min_distance: legacy_data.metadata.min_distance,
                },
                created_at: legacy_data.metadata.created_at,
                version: legacy_data.metadata.version,
            })
        }
    }
}

/// Legacy function: Starts a receiver thread that listens for ensemble data from MPSC channel
/// and saves it to disk with the specified tag
///
/// # Arguments
///
/// * `rx` - MPSC receiver channel for ensemble data
/// * `tag` - Tag name for the ensemble file
/// * `radius` - Sphere radius used for generation
/// * `speed` - Speed of birds
/// * `min_distance` - Minimum distance constraint
pub fn start_receiver(
    rx: mpsc::Receiver<Vec<Bird>>,
    tag: String,
    radius: f64,
    speed: f64,
    min_distance: f64,
) -> Result<(), Box<dyn std::error::Error>> {
    // Ensure ensemble directory exists
    crate::io::ensure_data_directories()?;

    // Receive ensemble data
    let birds = rx.recv()?;

    // Create metadata
    let metadata = EnsembleMetadata {
        tag: tag.clone(),
        num_birds: birds.len(),
        radius,
        speed,
        min_distance,
        created_at: SystemTime::now().duration_since(UNIX_EPOCH)?.as_secs(),
        version: env!("CARGO_PKG_VERSION").to_string(),
    };

    // Create ensemble data
    let ensemble_data = EnsembleData { birds, metadata };

    // Save to file
    save_ensemble(&ensemble_data, &tag)?;

    println!(
        "Ensemble '{}' saved successfully with {} birds",
        tag,
        ensemble_data.birds.len()
    );

    Ok(())
}

/// Saves ensemble data to a binary file
///
/// # Arguments
///
/// * `ensemble` - The ensemble data to save
/// * `tag` - Tag name for the file
pub fn save_ensemble(ensemble: &EnsembleData, tag: &str) -> Result<(), Box<dyn std::error::Error>> {
    let file_path = get_ensemble_path(tag);

    // Create parent directory if it doesn't exist
    if let Some(parent) = file_path.parent() {
        fs::create_dir_all(parent)?;
    }

    let file = File::create(&file_path)?;
    let writer = BufWriter::new(file);

    bincode::serialize_into(writer, ensemble)?;

    Ok(())
}

/// Loads ensemble data from a binary file
///
/// # Arguments
///
/// * `tag` - Tag name of the ensemble to load
pub fn load_ensemble(tag: &str) -> Result<EnsembleData, Box<dyn std::error::Error>> {
    let file_path = get_ensemble_path(tag);

    if !file_path.exists() {
        return Err(format!("Ensemble file not found: {}", file_path.display()).into());
    }

    let file = File::open(&file_path)?;
    let reader = BufReader::new(file);

    let ensemble: EnsembleData = bincode::deserialize_from(reader)?;

    Ok(ensemble)
}

/// Enumerates all ensemble files and verifies their status
pub fn enumerate_ensembles() -> Result<Vec<EnsembleStatus>, Box<dyn std::error::Error>> {
    let ensemble_dir = Path::new("./data/ensemble");

    if !ensemble_dir.exists() {
        return Ok(Vec::new());
    }

    let mut statuses = Vec::new();

    for entry in fs::read_dir(ensemble_dir)? {
        let entry = entry?;
        let path = entry.path();

        if path.extension().and_then(|s| s.to_str()) == Some("bin") {
            let status = verify_ensemble_file(&path);
            statuses.push(status);
        }
    }

    // Sort by creation time (newest first)
    statuses.sort_by(|a, b| match (&a.metadata, &b.metadata) {
        (Some(meta_a), Some(meta_b)) => meta_b.created_at.cmp(&meta_a.created_at),
        (Some(_), None) => std::cmp::Ordering::Less,
        (None, Some(_)) => std::cmp::Ordering::Greater,
        (None, None) => a.path.cmp(&b.path),
    });

    Ok(statuses)
}

/// Verifies the status of an ensemble file
fn verify_ensemble_file(path: &Path) -> EnsembleStatus {
    match load_ensemble_from_path(path) {
        Ok(ensemble) => EnsembleStatus {
            path: path.to_path_buf(),
            is_valid: true,
            error: None,
            metadata: Some(ensemble.metadata),
        },
        Err(e) => EnsembleStatus {
            path: path.to_path_buf(),
            is_valid: false,
            error: Some(e.to_string()),
            metadata: None,
        },
    }
}

/// Loads ensemble data from a specific file path
fn load_ensemble_from_path(path: &Path) -> Result<EnsembleData, Box<dyn std::error::Error>> {
    let file = File::open(path)?;
    let reader = BufReader::new(file);
    let ensemble: EnsembleData = bincode::deserialize_from(reader)?;
    Ok(ensemble)
}

/// Gets the file path for an ensemble with the given tag
pub fn get_ensemble_path(tag: &str) -> PathBuf {
    Path::new("./data/ensemble").join(format!("{}.bin", tag))
}

/// Lists all available ensemble tags
pub fn list_ensemble_tags() -> Result<Vec<String>, Box<dyn std::error::Error>> {
    let statuses = enumerate_ensembles()?;
    let tags: Vec<String> = statuses
        .into_iter()
        .filter_map(|status| {
            if status.is_valid {
                status.metadata.map(|meta| meta.tag)
            } else {
                None
            }
        })
        .collect();

    Ok(tags)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_simple_ensemble_workflow() {
        // Create a simple test ensemble manually  
        let ensemble = EnsembleResult {
            id: 1,
            tag: "simple_workflow_test".to_string(),
            birds: Vec::new(), // Empty for simplicity
            params: EnsembleGenerationParams {
                n_particles: 0,
                radius: 1.0,
                speed: 1.0,
                min_distance: 0.1,
            },
            created_at: std::time::SystemTime::now()
                .duration_since(std::time::UNIX_EPOCH)
                .unwrap()
                .as_secs(),
            version: env!("CARGO_PKG_VERSION").to_string(),
        };

        // Save the ensemble
        save_ensemble_result(&ensemble).expect("Should save ensemble");

        // Verify that ensemble was saved to disk
        let saved_tags = list_ensemble_tags().expect("Should be able to list ensemble tags");
        assert!(saved_tags.contains(&"simple_workflow_test".to_string()), 
                "simple_workflow_test should be saved");

        // Test loading ensemble back from disk
        let loaded_ensemble = load_ensemble_result("simple_workflow_test")
            .expect("Should be able to load ensemble");

        // Verify the loaded data matches expectations
        assert_eq!(loaded_ensemble.tag, "simple_workflow_test", "Tag should match");
        assert_eq!(loaded_ensemble.id, 1, "ID should match");
        assert!(loaded_ensemble.created_at > 0, "Should have creation timestamp");
        assert!(!loaded_ensemble.version.is_empty(), "Should have version info");

        // Clean up test file
        let file_path = get_ensemble_path("simple_workflow_test");
        if file_path.exists() {
            std::fs::remove_file(file_path).ok();
        }

        println!("✓ Simple ensemble workflow test passed!");
    }

    #[test]
    fn test_ensemble_save_and_load() {
        // Create a simple ensemble result for testing
        let test_ensemble = EnsembleResult {
            id: 42,
            tag: "save_load_test".to_string(),
            birds: Vec::new(), // Empty for simplicity
            params: EnsembleGenerationParams {
                n_particles: 0,
                radius: 1.0,
                speed: 1.0,
                min_distance: 0.1,
            },
            created_at: 1234567890,
            version: "test".to_string(),
        };

        // Save the ensemble
        save_ensemble_result(&test_ensemble).expect("Should save successfully");

        // Load it back
        let loaded = load_ensemble_result("save_load_test").expect("Should load successfully");

        // Verify data integrity
        assert_eq!(loaded.id, 42);
        assert_eq!(loaded.tag, "save_load_test");
        assert_eq!(loaded.birds.len(), 0);
        assert_eq!(loaded.created_at, 1234567890);
        assert_eq!(loaded.version, "test");

        // Clean up
        let file_path = get_ensemble_path("save_load_test");
        if file_path.exists() {
            std::fs::remove_file(file_path).ok();
        }

        println!("✓ Ensemble save and load test passed!");
    }
}
