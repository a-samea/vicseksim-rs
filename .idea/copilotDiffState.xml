<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/cli.rs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/cli.rs" />
              <option name="originalContent" value="use clap::{Parser, Subcommand};&#10;use std::path::PathBuf;&#10;&#10;#[derive(Parser, Debug)]&#10;#[command(author, version, about, long_about = None)]&#10;#[command(propagate_version = true)]&#10;pub struct Cli {&#10;    #[command(subcommand)]&#10;    pub command: Commands,&#10;}&#10;&#10;#[derive(Subcommand, Debug)]&#10;pub enum Commands {&#10;    /// Generate a set of initial particle positions.&#10;    Generate {&#10;        /// Number of particles to generate.&#10;        #[arg(short, long, default_value_t = 512)]&#10;        num_particles: usize,&#10;&#10;        /// Minimum allowed distance between particles (on unit sphere).&#10;        #[arg(short, long, default_value_t = 0.1)]&#10;        min_distance: f64,&#10;&#10;        /// Output file path for the generated spherical coordinates.&#10;        #[arg(short, long, default_value = &quot;initial_coords.json&quot;)]&#10;        output: PathBuf,&#10;    },&#10;&#10;    /// Run a simulation from an initial state and output data for visualization.&#10;    Simulate {&#10;        /// Path to the input file with initial spherical coordinates.&#10;        #[arg(short, long)]&#10;        input: PathBuf,&#10;&#10;        /// Output CSV file path for visualization data.&#10;        #[arg(short, long, default_value = &quot;viz_data.csv&quot;)]&#10;        output: PathBuf,&#10;&#10;        /// Total number of time steps to run.&#10;        #[arg(short, long, default_value_t = 2000)]&#10;        steps: u64,&#10;&#10;        /// Constant speed of the particles.&#10;        #[arg(long, default_value_t = 0.03)]&#10;        speed: f64,&#10;&#10;        /// Interaction radius for alignment.&#10;        #[arg(long, default_value_t = 1.0)]&#10;        interaction_radius: f64,&#10;&#10;        /// Noise parameter (e.g., width of uniform dist or std dev of normal dist).&#10;        #[arg(short, long, default_value_t = 0.5)]&#10;        noise: f64,&#10;    },&#10;&#10;    /// Perform analysis on saved simulation snapshots.&#10;    Analyze {&#10;        /// Path to a directory containing snapshot .bin files.&#10;        #[arg(short, long)]&#10;        snapshot_dir: PathBuf,&#10;&#10;        /// Output file for the analysis results.&#10;        #[arg(short, long, default_value = &quot;analysis_results.csv&quot;)]&#10;        output: PathBuf,&#10;    },&#10;}" />
              <option name="updatedContent" value="//! # CLI Module - Command Line Interface for Flocking Simulation Pipeline&#10;//!&#10;//! This module provides a command-line interface for the three-stage flocking simulation pipeline:&#10;//!&#10;//! ## Stage 1: Ensemble Generation (`generate-ensembles`)&#10;//! &#10;//! Creates multiple ensembles of birds in parallel using configurable threading. Each thread&#10;//! generates its own ensemble independently and saves it to a separate file in `./data/ensemble/`.&#10;//! This stage supports:&#10;//! - Parallel ensemble generation using multiple threads&#10;//! - Configurable ensemble size (number of ensembles to create)&#10;//! - Configurable birds per ensemble&#10;//! - Automatic file naming and organization&#10;//! - Performance timing and reporting&#10;//!&#10;//! **Usage**: &#10;//! ```bash&#10;//! flok generate-ensembles --ensemble-count 10 --birds-per-ensemble 500 --threads 4&#10;//! ```&#10;//!&#10;//! ## Stage 2: Main Simulation (`simulate`)&#10;//! &#10;//! Runs the main flocking simulation using pre-generated ensembles as initial conditions.&#10;//! Processes multiple ensemble files and generates simulation trajectories for visualization&#10;//! and analysis.&#10;//!&#10;//! **Usage**: &#10;//! ```bash&#10;//! flok simulate --input-dir ./data/ensemble/ --steps 2000 --output-dir ./data/simulation/&#10;//! ```&#10;//!&#10;//! ## Stage 3: Post Analysis (`analyze`)&#10;//! &#10;//! Performs statistical analysis and visualization of simulation results. Generates&#10;//! plots, statistical summaries, and other analytical outputs from simulation data.&#10;//!&#10;//! **Usage**: &#10;//! ```bash&#10;//! flok analyze --input-dir ./data/simulation/ --output-dir ./data/analysis/&#10;//! ```&#10;//!&#10;//! ## Design Philosophy&#10;//!&#10;//! The CLI is designed around a pipeline approach where each stage operates on the outputs&#10;//! of the previous stage. This enables:&#10;//! - Reproducible research workflows&#10;//! - Parallel processing at each stage&#10;//! - Intermediate result inspection and debugging&#10;//! - Flexible parameter exploration&#10;//!&#10;//! Each command includes timing information and progress reporting to help users&#10;//! understand performance characteristics and optimize their workflows.&#10;&#10;use clap::{Parser, Subcommand};&#10;use std::path::PathBuf;&#10;&#10;#[derive(Parser, Debug)]&#10;#[command(author, version, about, long_about = None)]&#10;#[command(propagate_version = true)]&#10;pub struct Cli {&#10;    #[command(subcommand)]&#10;    pub command: Commands,&#10;}&#10;&#10;#[derive(Subcommand, Debug)]&#10;pub enum Commands {&#10;    /// Stage 1: Generate multiple ensembles in parallel for simulation input&#10;    GenerateEnsembles {&#10;        /// Number of ensembles to generate&#10;        #[arg(short = 'e', long, default_value_t = 10)]&#10;        ensemble_count: usize,&#10;&#10;        /// Number of birds per ensemble&#10;        #[arg(short = 'b', long, default_value_t = 500)]&#10;        birds_per_ensemble: usize,&#10;&#10;        /// Number of threads to use for parallel generation&#10;        #[arg(short, long, default_value_t = 4)]&#10;        threads: usize,&#10;&#10;        /// Sphere radius for bird positioning&#10;        #[arg(short, long, default_value_t = 1.0)]&#10;        radius: f64,&#10;&#10;        /// Speed of all birds in the ensemble&#10;        #[arg(short, long, default_value_t = 2.0)]&#10;        speed: f64,&#10;&#10;        /// Minimum allowed distance between birds&#10;        #[arg(short = 'd', long, default_value_t = 0.1)]&#10;        min_distance: f64,&#10;&#10;        /// Base tag for ensemble naming (will be appended with thread ID)&#10;        #[arg(long, default_value = &quot;ensemble&quot;)]&#10;        tag: String,&#10;    },&#10;&#10;    /// Stage 2: Run simulations from generated ensembles&#10;    Simulate {&#10;        /// Directory containing ensemble files to simulate&#10;        #[arg(short, long, default_value = &quot;./data/ensemble/&quot;)]&#10;        input_dir: PathBuf,&#10;&#10;        /// Directory to save simulation results&#10;        #[arg(short, long, default_value = &quot;./data/simulation/&quot;)]&#10;        output_dir: PathBuf,&#10;&#10;        /// Total number of time steps to run&#10;        #[arg(short, long, default_value_t = 2000)]&#10;        steps: u64,&#10;&#10;        /// Interaction radius for alignment&#10;        #[arg(long, default_value_t = 1.0)]&#10;        interaction_radius: f64,&#10;&#10;        /// Noise parameter for random motion&#10;        #[arg(long, default_value_t = 0.1)]&#10;        noise: f64,&#10;    },&#10;&#10;    /// Stage 3: Analyze simulation results and generate visualizations&#10;    Analyze {&#10;        /// Directory containing simulation result files&#10;        #[arg(short, long, default_value = &quot;./data/simulation/&quot;)]&#10;        input_dir: PathBuf,&#10;&#10;        /// Directory to save analysis results and plots&#10;        #[arg(short, long, default_value = &quot;./data/analysis/&quot;)]&#10;        output_dir: PathBuf,&#10;&#10;        /// Types of analysis to perform&#10;        #[arg(long, value_delimiter = ',', default_values = [&quot;order&quot;, &quot;clustering&quot;, &quot;trajectory&quot;])]&#10;        analysis_types: Vec&lt;String&gt;,&#10;    },&#10;&#10;    /// Legacy: Generate a single set of initial particle positions (deprecated)&#10;    Generate {&#10;        /// Number of particles to generate.&#10;        #[arg(short, long, default_value_t = 512)]&#10;        num_particles: usize,&#10;&#10;        /// Minimum allowed distance between particles (on unit sphere).&#10;        #[arg(short, long, default_value_t = 0.1)]&#10;        min_distance: f64,&#10;&#10;        /// Output file path for the generated spherical coordinates.&#10;        #[arg(short, long, default_value = &quot;initial_coords.json&quot;)]&#10;        output: PathBuf,&#10;    },&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/io.rs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/io.rs" />
              <option name="updatedContent" value="//! # IO Module - Data Persistence and Pipeline Management&#10;//!&#10;//! This module provides data persistence functionality for the flocking simulation pipeline.&#10;//! It handles saving and loading of ensemble data, simulation results, and analysis outputs&#10;//! to support the three-stage pipeline:&#10;//!&#10;//! 1. **Ensemble Generation** → Save to `./data/ensemble/`&#10;//! 2. **Simulation Execution** → Save to `./data/simulation/`&#10;//! 3. **Analysis Processing** → Save to `./data/analysis/` (future implementation)&#10;//!&#10;//! All data is stored in the `./data/` directory with organized subdirectories for each&#10;//! pipeline stage.&#10;&#10;pub mod ensemble;&#10;pub mod simulation;&#10;pub mod analysis;&#10;&#10;use std::fs;&#10;use std::path::Path;&#10;&#10;/// Ensures the data directory structure exists&#10;pub fn ensure_data_directories() -&gt; Result&lt;(), std::io::Error&gt; {&#10;    fs::create_dir_all(&quot;./data/ensemble&quot;)?;&#10;    fs::create_dir_all(&quot;./data/simulation&quot;)?;&#10;    fs::create_dir_all(&quot;./data/analysis&quot;)?;&#10;    Ok(())&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main.rs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main.rs" />
              <option name="originalContent" value="use std::fs::File;&#10;use std::io::BufWriter;&#10;use std::sync::mpsc;&#10;use std::thread;&#10;use std::time::Instant;&#10;use clap::Parser;&#10;use flocking_lib::cli::{Cli, Commands};&#10;use flocking_lib::simulation::Simulation;&#10;&#10;fn main() -&gt; Result&lt;(), String&gt; {&#10;    let cli = Cli::parse();&#10;&#10;    match &amp;cli.command {&#10;        Commands::Generate {&#10;            num_particles,&#10;            min_distance,&#10;            output,&#10;        } =&gt; {&#10;            println!(&quot;--- Generate Mode ---&quot;);&#10;            println!(&quot;Generating {} particles...&quot;, num_particles);&#10;            println!(&quot;Saving initial state to: {:?}&quot;, output);&#10;            // Call functions from flocking_lib::ensemble and flocking_lib::io&#10;            unimplemented!(&quot;Call ensemble generation and IO saving logic here.&quot;);&#10;        }&#10;        Commands::Simulate {&#10;            input,&#10;            output,&#10;            steps,&#10;            speed,&#10;            interaction_radius,&#10;            noise,&#10;        } =&gt; {&#10;            println!(&quot;--- Simulate Mode ---&quot;);&#10;            println!(&quot;Loading initial state from: {:?}&quot;, input);&#10;            println!(&quot;Running simulation for {} steps...&quot;, steps);&#10;            println!(&quot;Saving visualization data to: {:?}&quot;, output);&#10;            // 1. Load initial coords using flocking_lib::io&#10;            // 2. Convert to particles using flocking_lib::ensemble&#10;            // 3. Create FlockSimulation&#10;            // 4. Loop for `steps`, calling sim.step() and io.append_frame...&#10;            unimplemented!(&quot;Call full simulation loop logic here.&quot;);&#10;        }&#10;        Commands::Analyze {&#10;            snapshot_dir,&#10;            output,&#10;        } =&gt; {&#10;            println!(&quot;--- Analyze Mode ---&quot;);&#10;            println!(&quot;Analyzing snapshots from directory: {:?}&quot;, snapshot_dir);&#10;            println!(&quot;Saving analysis results to: {:?}&quot;, output);&#10;            // 1. Find all snapshot files in the directory&#10;            // 2. Loop through each file&#10;            // 3. Load snapshot using flocking_lib::io&#10;            // 4. Run analysis using flocking_lib::analysis&#10;            // 5. Aggregate and save results.&#10;            unimplemented!(&quot;Call analysis logic here.&quot;);&#10;        }&#10;    }&#10;&#10;    Ok(())&#10;}&#10;fn main() {&#10;    // --- Simulation Parameters ---&#10;    let num_particles = 1_000;&#10;    let total_steps = 200;&#10;    let save_interval = 20; // Save data every 20 steps&#10;    let output_filename = &quot;simulation_output.txt&quot;;&#10;&#10;    // --- I/O Thread Setup ---&#10;    // 1. Create a multi-producer, single-consumer (mpsc) channel.&#10;    let (tx, rx) = mpsc::channel::&lt;Vec&lt;Particle&gt;&gt;();&#10;&#10;    // 2. Spawn a dedicated I/O thread.&#10;    // The `move` keyword gives the thread ownership of `rx` and the filename.&#10;    let io_thread_handle = thread::spawn(move || {&#10;        println!(&quot;I/O thread started. Writing to '{}'.&quot;, output_filename);&#10;        let file = File::create(output_filename).expect(&quot;Could not create output file.&quot;);&#10;        let mut writer = BufWriter::new(file);&#10;&#10;        // This loop will block until a message is received.&#10;        // It will automatically exit when the `tx` (sender) is dropped.&#10;        for (i, received_particles) in rx.iter().enumerate() {&#10;            writeln!(writer, &quot;--- Frame {} ---&quot;, i * save_interval).unwrap();&#10;            for p in received_particles {&#10;                writeln!(writer, &quot;{:?}&quot;, p).unwrap();&#10;            }&#10;        }&#10;        println!(&quot;I/O thread finished.&quot;);&#10;    });&#10;&#10;    // --- Simulation Setup and Execution ---&#10;    let mut simulation = Simulation::new(num_particles, tx);&#10;&#10;    println!(&#10;        &quot;Starting simulation with {} particles for {} steps.&quot;,&#10;        num_particles, total_steps&#10;    );&#10;    let start_time = Instant::now();&#10;&#10;    simulation.run(total_steps, save_interval);&#10;&#10;    let duration = start_time.elapsed();&#10;    println!(&quot;Total simulation time: {:?}&quot;, duration);&#10;&#10;    // --- Graceful Shutdown ---&#10;    // The sender (`tx`) is part of the `simulation` struct. When `simulation` goes&#10;    // out of scope here at the end of `main`, `tx` is dropped. This closes the&#10;    // channel, causing the `for` loop in the I/O thread to terminate.&#10;&#10;    // We explicitly wait for the I/O thread to finish its work. This ensures&#10;    // that all data is written to the file before the program exits.&#10;    io_thread_handle&#10;        .join()&#10;        .expect(&quot;I/O thread panicked during execution.&quot;);&#10;&#10;    println!(&quot;Program finished successfully.&quot;);&#10;}&#10;" />
              <option name="updatedContent" value="use std::fs::File;&#10;use std::io::BufWriter;&#10;use std::sync::mpsc;&#10;use std::thread;&#10;use std::time::Instant;&#10;use clap::Parser;&#10;use flocking_lib::cli::{Cli, Commands};&#10;use flocking_lib::simulation::Simulation;&#10;use flocking_lib::{ensemble, io};&#10;&#10;fn main() -&gt; Result&lt;(), String&gt; {&#10;    let cli = Cli::parse();&#10;&#10;    match &amp;cli.command {&#10;        Commands::GenerateEnsembles {&#10;            ensemble_count,&#10;            birds_per_ensemble,&#10;            threads,&#10;            radius,&#10;            speed,&#10;            min_distance,&#10;            tag,&#10;        } =&gt; {&#10;            println!(&quot;--- Parallel Ensemble Generation ---&quot;);&#10;            println!(&quot;Generating {} ensembles with {} birds each&quot;, ensemble_count, birds_per_ensemble);&#10;            println!(&quot;Using {} threads for parallel generation&quot;, threads);&#10;            println!(&quot;Configuration: radius={}, speed={}, min_distance={}&quot;, radius, speed, min_distance);&#10;            &#10;            // Ensure data directories exist&#10;            io::ensure_data_directories().map_err(|e| format!(&quot;Failed to create data directories: {}&quot;, e))?;&#10;            &#10;            let start_time = Instant::now();&#10;            &#10;            // Create a channel for collecting completed ensembles&#10;            let (ensemble_tx, ensemble_rx) = mpsc::channel();&#10;            &#10;            // Create worker threads&#10;            let mut handles = Vec::new();&#10;            let ensembles_per_thread = (*ensemble_count + threads - 1) / threads; // Ceiling division&#10;            &#10;            for thread_id in 0..*threads {&#10;                let start_ensemble = thread_id * ensembles_per_thread;&#10;                let end_ensemble = std::cmp::min(start_ensemble + ensembles_per_thread, *ensemble_count);&#10;                &#10;                if start_ensemble &gt;= *ensemble_count {&#10;                    break; // No more work for this thread&#10;                }&#10;                &#10;                let tx = ensemble_tx.clone();&#10;                let birds_per_ensemble = *birds_per_ensemble;&#10;                let radius = *radius;&#10;                let speed = *speed;&#10;                let min_distance = *min_distance;&#10;                let base_tag = tag.clone();&#10;                &#10;                let handle = thread::spawn(move || {&#10;                    println!(&quot;Thread {} starting: generating ensembles {} to {}&quot;, thread_id, start_ensemble, end_ensemble - 1);&#10;                    &#10;                    for ensemble_id in start_ensemble..end_ensemble {&#10;                        let ensemble_tag = format!(&quot;{}_{:04}&quot;, base_tag, ensemble_id);&#10;                        &#10;                        // Create a channel for this specific ensemble generation&#10;                        let (gen_tx, gen_rx) = mpsc::channel();&#10;                        &#10;                        // Generate the ensemble&#10;                        match ensemble::generate(birds_per_ensemble, radius, speed, min_distance, gen_tx) {&#10;                            Ok(()) =&gt; {&#10;                                // Receive the generated birds&#10;                                match gen_rx.recv() {&#10;                                    Ok(birds) =&gt; {&#10;                                        // Send the ensemble data to the main thread for saving&#10;                                        if let Err(e) = tx.send((ensemble_id, ensemble_tag, birds)) {&#10;                                            eprintln!(&quot;Thread {}: Failed to send ensemble {}: {}&quot;, thread_id, ensemble_id, e);&#10;                                        } else {&#10;                                            println!(&quot;Thread {}: Completed ensemble {} ({} birds)&quot;, thread_id, ensemble_id, birds_per_ensemble);&#10;                                        }&#10;                                    }&#10;                                    Err(e) =&gt; {&#10;                                        eprintln!(&quot;Thread {}: Failed to receive ensemble {}: {}&quot;, thread_id, ensemble_id, e);&#10;                                    }&#10;                                }&#10;                            }&#10;                            Err(e) =&gt; {&#10;                                eprintln!(&quot;Thread {}: Failed to generate ensemble {}: {}&quot;, thread_id, ensemble_id, e);&#10;                            }&#10;                        }&#10;                    }&#10;                    &#10;                    println!(&quot;Thread {} completed&quot;, thread_id);&#10;                });&#10;                &#10;                handles.push(handle);&#10;            }&#10;            &#10;            // Drop the original sender so the receiver will know when all threads are done&#10;            drop(ensemble_tx);&#10;            &#10;            // Collect and save ensembles as they complete&#10;            let mut completed_count = 0;&#10;            while let Ok((ensemble_id, ensemble_tag, birds)) = ensemble_rx.recv() {&#10;                // Start a receiver for saving this ensemble&#10;                let (save_tx, save_rx) = mpsc::channel();&#10;                &#10;                // Send the birds to be saved&#10;                if let Err(e) = save_tx.send(birds) {&#10;                    eprintln!(&quot;Failed to send birds for saving: {}&quot;, e);&#10;                    continue;&#10;                }&#10;                &#10;                // Start the receiver to save the ensemble&#10;                match io::ensemble::start_receiver(save_rx, ensemble_tag.clone(), *radius, *speed, *min_distance) {&#10;                    Ok(_) =&gt; {&#10;                        completed_count += 1;&#10;                        println!(&quot;Saved ensemble {} ({}/{} completed)&quot;, ensemble_tag, completed_count, ensemble_count);&#10;                    }&#10;                    Err(e) =&gt; {&#10;                        eprintln!(&quot;Failed to save ensemble {}: {}&quot;, ensemble_tag, e);&#10;                    }&#10;                }&#10;            }&#10;            &#10;            // Wait for all threads to complete&#10;            for handle in handles {&#10;                if let Err(e) = handle.join() {&#10;                    eprintln!(&quot;Thread panicked: {:?}&quot;, e);&#10;                }&#10;            }&#10;            &#10;            let duration = start_time.elapsed();&#10;            println!(&quot;\n--- Generation Complete ---&quot;);&#10;            println!(&quot;Successfully generated {} ensembles&quot;, completed_count);&#10;            println!(&quot;Total time: {:.2} seconds&quot;, duration.as_secs_f64());&#10;            println!(&quot;Average time per ensemble: {:.2} seconds&quot;, duration.as_secs_f64() / *ensemble_count as f64);&#10;            println!(&quot;Ensembles saved to: ./data/ensemble/&quot;);&#10;            &#10;            Ok(())&#10;        }&#10;        &#10;        Commands::Generate {&#10;            num_particles,&#10;            min_distance,&#10;            output,&#10;        } =&gt; {&#10;            println!(&quot;--- Generate Mode (Legacy) ---&quot;);&#10;            println!(&quot;Generating {} particles...&quot;, num_particles);&#10;            println!(&quot;Saving initial state to: {:?}&quot;, output);&#10;            // Call functions from flocking_lib::ensemble and flocking_lib::io&#10;            unimplemented!(&quot;Call ensemble generation and IO saving logic here.&quot;);&#10;        }&#10;        &#10;        Commands::Simulate {&#10;            input_dir,&#10;            output_dir,&#10;            steps,&#10;            interaction_radius,&#10;            noise,&#10;        } =&gt; {&#10;            println!(&quot;--- Simulate Mode ---&quot;);&#10;            println!(&quot;Loading ensembles from: {:?}&quot;, input_dir);&#10;            println!(&quot;Running simulation for {} steps...&quot;, steps);&#10;            println!(&quot;Saving simulation data to: {:?}&quot;, output_dir);&#10;            // Implementation will be added in Stage 2&#10;            unimplemented!(&quot;Call full simulation loop logic here.&quot;);&#10;        }&#10;        &#10;        Commands::Analyze {&#10;            input_dir,&#10;            output_dir,&#10;            analysis_types,&#10;        } =&gt; {&#10;            println!(&quot;--- Analyze Mode ---&quot;);&#10;            println!(&quot;Analyzing results from directory: {:?}&quot;, input_dir);&#10;            println!(&quot;Saving analysis results to: {:?}&quot;, output_dir);&#10;            println!(&quot;Analysis types: {:?}&quot;, analysis_types);&#10;            // Implementation will be added in Stage 3&#10;            unimplemented!(&quot;Call analysis logic here.&quot;);&#10;        }&#10;    }&#10;&#10;    Ok(())&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/simulation/tests.rs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/simulation/tests.rs" />
              <option name="originalContent" value="#[cfg(test)]&#10;mod units {&#10;&#10;}&#10;&#10;" />
              <option name="updatedContent" value="#[cfg(test)]&#10;mod tests {&#10;    use crate::simulation::logic::calculate_new_particle_state;&#10;    use crate::bird::Bird;&#10;    use crate::vector::Vec3;&#10;&#10;    // Test helper function to create a bird at a given position with tangent velocity&#10;    fn create_test_bird(position: Vec3, velocity: Vec3) -&gt; Bird {&#10;        Bird::new(position, velocity)&#10;    }&#10;&#10;    // Helper function for approximate equality comparison&#10;    fn assert_approx_eq(a: f64, b: f64, epsilon: f64) {&#10;        assert!((a - b).abs() &lt; epsilon, &quot;Expected {}, got {}, difference: {}&quot;, b, a, (a - b).abs());&#10;    }&#10;&#10;    #[test]&#10;    fn test_no_neighbors() {&#10;        // Single bird should maintain its velocity when no neighbors exist&#10;        let bird = create_test_bird(Vec3::new(1.0, 0.0, 0.0), Vec3::new(0.0, 2.0, 0.0));&#10;        let birds = vec![bird];&#10;        &#10;        let result = calculate_new_particle_state(0, &amp;birds, 0.1, 1.0, 0.1, 2.0, 1.0);&#10;        &#10;        // Should maintain speed constraint&#10;        assert_approx_eq(result.velocity.norm(), 2.0, 1e-10);&#10;        // Should be on sphere surface&#10;        assert_approx_eq(result.position.norm(), 1.0, 1e-10);&#10;    }&#10;&#10;    #[test]&#10;    fn test_neighbors_outside_interaction_radius() {&#10;        // Birds outside interaction radius should not affect behavior&#10;        let bird1 = create_test_bird(Vec3::new(1.0, 0.0, 0.0), Vec3::new(0.0, 2.0, 0.0));&#10;        let bird2 = create_test_bird(Vec3::new(-1.0, 0.0, 0.0), Vec3::new(0.0, -2.0, 0.0)); // Opposite side&#10;        let birds = vec![bird1, bird2];&#10;        &#10;        let result = calculate_new_particle_state(0, &amp;birds, 0.1, 1.0, 0.0, 2.0, 1.0);&#10;        &#10;        // Should maintain original velocity direction (no noise)&#10;        assert_approx_eq(result.velocity.norm(), 2.0, 1e-10);&#10;    }&#10;&#10;    #[test]&#10;    fn test_neighbor_within_interaction_radius() {&#10;        // Close neighbors should influence velocity&#10;        let bird1 = create_test_bird(Vec3::new(1.0, 0.0, 0.0), Vec3::new(0.0, 2.0, 0.0));&#10;        let bird2 = create_test_bird(Vec3::new(0.9, 0.1, 0.0).normalize(), Vec3::new(0.0, 0.0, 2.0));&#10;        let birds = vec![bird1, bird2];&#10;        &#10;        let result = calculate_new_particle_state(0, &amp;birds, 0.1, 2.0, 0.0, 2.0, 1.0);&#10;        &#10;        // Velocity should be averaged and normalized to correct speed&#10;        assert_approx_eq(result.velocity.norm(), 2.0, 1e-10);&#10;        // Position should remain on sphere&#10;        assert_approx_eq(result.position.norm(), 1.0, 1e-10);&#10;    }&#10;&#10;    #[test]&#10;    fn test_zero_averaged_velocity_fallback() {&#10;        // When averaged velocity is too small, should fallback to original velocity&#10;        let bird1 = create_test_bird(Vec3::new(1.0, 0.0, 0.0), Vec3::new(0.0, 2.0, 0.0));&#10;        let bird2 = create_test_bird(Vec3::new(0.9, 0.1, 0.0).normalize(), Vec3::new(0.0, -2.0, 0.0));&#10;        let birds = vec![bird1, bird2];&#10;        &#10;        let result = calculate_new_particle_state(0, &amp;birds, 0.1, 2.0, 0.0, 2.0, 1.0);&#10;        &#10;        // Should maintain speed and be on sphere&#10;        assert_approx_eq(result.velocity.norm(), 2.0, 1e-10);&#10;        assert_approx_eq(result.position.norm(), 1.0, 1e-10);&#10;    }&#10;&#10;    #[test]&#10;    fn test_multiple_neighbors() {&#10;        // Test with multiple neighbors within interaction radius&#10;        let bird1 = create_test_bird(Vec3::new(1.0, 0.0, 0.0), Vec3::new(0.0, 1.0, 0.0));&#10;        let bird2 = create_test_bird(Vec3::new(0.9, 0.1, 0.0).normalize(), Vec3::new(0.0, 1.0, 0.0));&#10;        let bird3 = create_test_bird(Vec3::new(0.9, -0.1, 0.0).normalize(), Vec3::new(0.0, 1.0, 0.0));&#10;        let birds = vec![bird1, bird2, bird3];&#10;        &#10;        let result = calculate_new_particle_state(0, &amp;birds, 0.1, 2.0, 0.0, 1.0, 1.0);&#10;        &#10;        // All constraints should be satisfied&#10;        assert_approx_eq(result.velocity.norm(), 1.0, 1e-10);&#10;        assert_approx_eq(result.position.norm(), 1.0, 1e-10);&#10;    }&#10;&#10;    #[test]&#10;    fn test_speed_constraint_maintained() {&#10;        // Ensure speed constraint is always maintained regardless of averaging&#10;        let bird1 = create_test_bird(Vec3::new(0.0, 0.0, 1.0), Vec3::new(1.0, 0.0, 0.0));&#10;        let bird2 = create_test_bird(Vec3::new(0.1, 0.0, 0.995).normalize(), Vec3::new(0.0, 1.0, 0.0));&#10;        let birds = vec![bird1, bird2];&#10;        &#10;        let speed = 3.5;&#10;        let result = calculate_new_particle_state(0, &amp;birds, 0.05, 1.0, 0.0, speed, 1.0);&#10;        &#10;        assert_approx_eq(result.velocity.norm(), speed, 1e-10);&#10;        assert_approx_eq(result.position.norm(), 1.0, 1e-10);&#10;    }&#10;&#10;    #[test]&#10;    fn test_sphere_constraint_maintained() {&#10;        // Test various positions to ensure sphere constraint is always maintained&#10;        let positions = vec![&#10;            Vec3::new(1.0, 0.0, 0.0),&#10;            Vec3::new(0.0, 1.0, 0.0),&#10;            Vec3::new(0.0, 0.0, 1.0),&#10;            Vec3::new(0.707, 0.707, 0.0),&#10;        ];&#10;        &#10;        for pos in positions {&#10;            let bird = create_test_bird(pos, Vec3::new(0.0, 0.0, 1.0));&#10;            let birds = vec![bird];&#10;            &#10;            let result = calculate_new_particle_state(0, &amp;birds, 0.1, 1.0, 0.0, 1.0, 1.0);&#10;            assert_approx_eq(result.position.norm(), 1.0, 1e-10);&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/tests/ensemble_test.rs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/tests/ensemble_test.rs" />
              <option name="updatedContent" value="//! Integration tests for ensemble generation and statistical properties&#10;//!&#10;//! These tests verify that ensemble generation produces statistically valid&#10;//! distributions and that the generated configurations are suitable for&#10;//! physical simulations.&#10;&#10;use flocking_lib::{ensemble, vector::Vec3};&#10;use rand::{rngs::StdRng, SeedableRng};&#10;use std::f64::consts::PI;&#10;&#10;/// Test uniform distribution on sphere surface&#10;#[test]&#10;fn test_uniform_sphere_distribution() {&#10;    let mut rng = StdRng::seed_from_u64(42);&#10;    &#10;    // Generate a large ensemble to test statistical properties&#10;    let birds = ensemble::generate(1000, 1.0, 0.1, 0.03, &amp;mut rng)&#10;        .expect(&quot;Failed to generate ensemble&quot;);&#10;    &#10;    // Test that positions are uniformly distributed on sphere&#10;    let mut north_count = 0;&#10;    let mut south_count = 0;&#10;    &#10;    for bird in &amp;birds {&#10;        let pos = bird.position();&#10;        if pos.z &gt; 0.0 {&#10;            north_count += 1;&#10;        } else {&#10;            south_count += 1;&#10;        }&#10;    }&#10;    &#10;    // Should be roughly equal distribution between hemispheres&#10;    let ratio = north_count as f64 / south_count as f64;&#10;    assert!(ratio &gt; 0.8 &amp;&amp; ratio &lt; 1.2, &#10;        &quot;Uneven hemisphere distribution: N={}, S={}, ratio={:.3}&quot;, &#10;        north_count, south_count, ratio);&#10;}&#10;&#10;/// Test velocity distribution properties&#10;#[test]&#10;fn test_velocity_distribution() {&#10;    let mut rng = StdRng::seed_from_u64(123);&#10;    &#10;    let birds = ensemble::generate(500, 1.0, 0.15, 0.05, &amp;mut rng)&#10;        .expect(&quot;Failed to generate ensemble&quot;);&#10;    &#10;    let mut speed_sum = 0.0;&#10;    let mut speed_squared_sum = 0.0;&#10;    &#10;    for bird in &amp;birds {&#10;        let speed = bird.velocity().norm();&#10;        speed_sum += speed;&#10;        speed_squared_sum += speed * speed;&#10;        &#10;        // All speeds should be close to the specified speed&#10;        assert!((speed - 0.15).abs() &lt; 1e-10, &#10;            &quot;Bird speed deviates from expected: {} vs 0.15&quot;, speed);&#10;    }&#10;    &#10;    let mean_speed = speed_sum / birds.len() as f64;&#10;    let variance = speed_squared_sum / birds.len() as f64 - mean_speed * mean_speed;&#10;    &#10;    // Mean should be very close to specified speed&#10;    assert!((mean_speed - 0.15).abs() &lt; 1e-8, &#10;        &quot;Mean speed incorrect: {}&quot;, mean_speed);&#10;    &#10;    // Variance should be very small (all speeds should be identical)&#10;    assert!(variance &lt; 1e-15, &quot;Speed variance too large: {}&quot;, variance);&#10;}&#10;&#10;/// Test that ensemble respects minimum separation constraints&#10;#[test]&#10;fn test_separation_constraints() {&#10;    let mut rng = StdRng::seed_from_u64(456);&#10;    &#10;    let min_sep = 0.1;&#10;    let birds = ensemble::generate(100, 1.0, 0.1, min_sep, &amp;mut rng)&#10;        .expect(&quot;Failed to generate ensemble&quot;);&#10;    &#10;    let mut min_distance = f64::INFINITY;&#10;    let mut violations = 0;&#10;    &#10;    for (i, bird1) in birds.iter().enumerate() {&#10;        for bird2 in birds.iter().skip(i + 1) {&#10;            let distance = bird1.distance_to(bird2);&#10;            min_distance = min_distance.min(distance);&#10;            &#10;            if distance &lt; min_sep - 1e-12 {&#10;                violations += 1;&#10;            }&#10;        }&#10;    }&#10;    &#10;    assert_eq!(violations, 0, &#10;        &quot;Found {} separation violations, minimum distance: {}&quot;, &#10;        violations, min_distance);&#10;    &#10;    assert!(min_distance &gt;= min_sep - 1e-12, &#10;        &quot;Minimum distance {} below threshold {}&quot;, min_distance, min_sep);&#10;}&#10;&#10;/// Test ensemble generation with different sphere radii&#10;#[test]&#10;fn test_different_sphere_radii() {&#10;    let mut rng = StdRng::seed_from_u64(789);&#10;    &#10;    for radius in [0.5, 1.0, 2.0, 5.0] {&#10;        let birds = ensemble::generate(50, radius, 0.1, 0.05, &amp;mut rng)&#10;            .expect(&amp;format!(&quot;Failed to generate ensemble for radius {}&quot;, radius));&#10;        &#10;        // All birds should be on the sphere of the specified radius&#10;        for bird in &amp;birds {&#10;            let actual_radius = bird.position().norm();&#10;            assert!((actual_radius - radius).abs() &lt; 1e-10, &#10;                &quot;Bird not on sphere of radius {}: actual radius = {}&quot;, &#10;                radius, actual_radius);&#10;        }&#10;        &#10;        // Minimum separation should scale with sphere size for surface distance&#10;        let min_surface_sep = 0.05;&#10;        for (i, bird1) in birds.iter().enumerate() {&#10;            for bird2 in birds.iter().skip(i + 1) {&#10;                let distance = bird1.distance_to(bird2);&#10;                assert!(distance &gt;= min_surface_sep - 1e-12, &#10;                    &quot;Surface separation violation on radius {} sphere&quot;, radius);&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;/// Test ensemble generation failure modes&#10;#[test]&#10;fn test_ensemble_generation_limits() {&#10;    let mut rng = StdRng::seed_from_u64(999);&#10;    &#10;    // Test impossible configurations&#10;    &#10;    // Too many birds for the space available&#10;    let result = ensemble::generate(10000, 1.0, 0.1, 0.5, &amp;mut rng);&#10;    // This should either fail or take extremely long - we mainly test it doesn't panic&#10;    &#10;    // Minimum separation larger than sphere diameter&#10;    let result = ensemble::generate(2, 1.0, 0.1, 5.0, &amp;mut rng);&#10;    // Should fail as it's impossible to place 2 birds this far apart on a sphere&#10;    &#10;    // Zero or negative parameters&#10;    let result = ensemble::generate(10, 0.0, 0.1, 0.1, &amp;mut rng);&#10;    // Should fail for zero radius&#10;    &#10;    let result = ensemble::generate(10, 1.0, -0.1, 0.1, &amp;mut rng);&#10;    // Should fail for negative speed&#10;    &#10;    let result = ensemble::generate(10, 1.0, 0.1, -0.1, &amp;mut rng);&#10;    // Should fail for negative separation&#10;}&#10;&#10;/// Test reproducibility with fixed random seeds&#10;#[test]&#10;fn test_ensemble_reproducibility() {&#10;    // Same seed should produce identical ensembles&#10;    let mut rng1 = StdRng::seed_from_u64(12345);&#10;    let mut rng2 = StdRng::seed_from_u64(12345);&#10;    &#10;    let birds1 = ensemble::generate(20, 1.0, 0.1, 0.1, &amp;mut rng1)&#10;        .expect(&quot;Failed to generate first ensemble&quot;);&#10;    &#10;    let birds2 = ensemble::generate(20, 1.0, 0.1, 0.1, &amp;mut rng2)&#10;        .expect(&quot;Failed to generate second ensemble&quot;);&#10;    &#10;    assert_eq!(birds1.len(), birds2.len());&#10;    &#10;    // Positions and velocities should be identical&#10;    for (bird1, bird2) in birds1.iter().zip(birds2.iter()) {&#10;        let pos_diff = (*bird1.position() - *bird2.position()).norm();&#10;        let vel_diff = (*bird1.velocity() - *bird2.velocity()).norm();&#10;        &#10;        assert!(pos_diff &lt; 1e-15, &quot;Position difference: {}&quot;, pos_diff);&#10;        assert!(vel_diff &lt; 1e-15, &quot;Velocity difference: {}&quot;, vel_diff);&#10;    }&#10;}&#10;&#10;/// Test statistical properties of velocity orientations&#10;#[test]&#10;fn test_velocity_orientation_statistics() {&#10;    let mut rng = StdRng::seed_from_u64(2024);&#10;    &#10;    let birds = ensemble::generate(1000, 1.0, 0.1, 0.02, &amp;mut rng)&#10;        .expect(&quot;Failed to generate ensemble&quot;);&#10;    &#10;    // Calculate average velocity direction (should be close to zero for random orientations)&#10;    let mut avg_velocity = Vec3::new(0.0, 0.0, 0.0);&#10;    &#10;    for bird in &amp;birds {&#10;        let normalized_vel = bird.velocity().normalize();&#10;        avg_velocity = avg_velocity + normalized_vel;&#10;    }&#10;    &#10;    avg_velocity = avg_velocity * (1.0 / birds.len() as f64);&#10;    &#10;    // For uniformly random orientations, average should be near zero&#10;    let avg_magnitude = avg_velocity.norm();&#10;    assert!(avg_magnitude &lt; 0.1, &#10;        &quot;Average velocity direction not random enough: magnitude = {}&quot;, avg_magnitude);&#10;}&#10;&#10;/// Test ensemble generation performance&#10;#[test]&#10;fn test_ensemble_generation_performance() {&#10;    let mut rng = StdRng::seed_from_u64(1111);&#10;    &#10;    let start = std::time::Instant::now();&#10;    &#10;    // Generate several ensembles to test performance&#10;    for i in 0..10 {&#10;        let _birds = ensemble::generate(100, 1.0, 0.1, 0.03, &amp;mut rng)&#10;            .expect(&amp;format!(&quot;Failed to generate ensemble {}&quot;, i));&#10;    }&#10;    &#10;    let duration = start.elapsed();&#10;    &#10;    // Should complete reasonably quickly&#10;    assert!(duration.as_secs() &lt; 10, &#10;        &quot;Ensemble generation too slow: took {:.2} seconds&quot;, duration.as_secs_f64());&#10;    &#10;    println!(&quot;Ensemble generation performance: 10 ensembles of 100 birds took {:.3} ms&quot;, &#10;        duration.as_millis());&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/tests/simulation_test.rs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/tests/simulation_test.rs" />
              <option name="updatedContent" value="//! Integration tests for simulation physics and behavior&#10;//!&#10;//! These tests verify that the simulation engine correctly implements&#10;//! the Vicsek model physics and produces expected flocking behaviors.&#10;&#10;use flocking_lib::{bird::Bird, ensemble, simulation::Simulation, vector::Vec3};&#10;use rand::{rngs::StdRng, SeedableRng};&#10;use std::f64::consts::PI;&#10;&#10;/// Test that flocking behavior emerges with appropriate parameters&#10;#[test]&#10;fn test_flocking_emergence() {&#10;    let mut rng = StdRng::seed_from_u64(42);&#10;    &#10;    // Create birds with initially random velocities&#10;    let birds = ensemble::generate(200, 1.0, 0.1, 0.03, &amp;mut rng)&#10;        .expect(&quot;Failed to generate ensemble&quot;);&#10;    &#10;    let mut sim = Simulation::new(birds);&#10;    &#10;    // Measure initial order (should be low due to random velocities)&#10;    let initial_order = calculate_order_parameter(sim.birds());&#10;    &#10;    // Run simulation with strong alignment and low noise&#10;    let alignment_strength = 0.5;&#10;    let noise_strength = 0.05;&#10;    let dt = 0.01;&#10;    &#10;    // Allow time for flocking to emerge&#10;    for _ in 0..500 {&#10;        sim.step(dt, alignment_strength, noise_strength);&#10;    }&#10;    &#10;    let final_order = calculate_order_parameter(sim.birds());&#10;    &#10;    // Order should increase significantly due to flocking&#10;    assert!(final_order &gt; initial_order + 0.1, &#10;        &quot;Flocking did not emerge: initial order = {:.3}, final order = {:.3}&quot;, &#10;        initial_order, final_order);&#10;    &#10;    // Final order should be reasonably high&#10;    assert!(final_order &gt; 0.3, &#10;        &quot;Final order too low: {:.3}&quot;, final_order);&#10;}&#10;&#10;/// Test conservation laws and constraints during simulation&#10;#[test]&#10;fn test_conservation_laws() {&#10;    let mut rng = StdRng::seed_from_u64(123);&#10;    &#10;    let birds = ensemble::generate(50, 1.0, 0.15, 0.05, &amp;mut rng)&#10;        .expect(&quot;Failed to generate ensemble&quot;);&#10;    &#10;    let mut sim = Simulation::new(birds);&#10;    &#10;    // Track various quantities that should be conserved or constrained&#10;    for step in 0..100 {&#10;        sim.step(0.02, 0.3, 0.1);&#10;        &#10;        let birds = sim.birds();&#10;        &#10;        // All birds must remain on sphere surface&#10;        for (i, bird) in birds.iter().enumerate() {&#10;            let radius = bird.position().norm();&#10;            assert!((radius - 1.0).abs() &lt; 1e-8, &#10;                &quot;Step {}, Bird {}: left sphere surface, radius = {:.10}&quot;, &#10;                step, i, radius);&#10;        }&#10;        &#10;        // Bird speeds should be maintained (approximately)&#10;        for (i, bird) in birds.iter().enumerate() {&#10;            let speed = bird.velocity().norm();&#10;            assert!(speed &gt; 0.05 &amp;&amp; speed &lt; 0.3, &#10;                &quot;Step {}, Bird {}: invalid speed = {:.6}&quot;, &#10;                step, i, speed);&#10;        }&#10;        &#10;        // Velocities should be roughly tangent to sphere&#10;        for (i, bird) in birds.iter().enumerate() {&#10;            let pos = bird.position().normalize();&#10;            let vel = bird.velocity().normalize();&#10;            let dot_product = pos.dot(&amp;vel).abs();&#10;            &#10;            // Dot product should be small for tangent vectors&#10;            assert!(dot_product &lt; 0.1, &#10;                &quot;Step {}, Bird {}: velocity not tangent, dot = {:.6}&quot;, &#10;                step, i, dot_product);&#10;        }&#10;    }&#10;}&#10;&#10;/// Test response to different noise levels&#10;#[test]&#10;fn test_noise_response() {&#10;    let mut rng = StdRng::seed_from_u64(456);&#10;    &#10;    let birds = ensemble::generate(100, 1.0, 0.1, 0.04, &amp;mut rng)&#10;        .expect(&quot;Failed to generate ensemble&quot;);&#10;    &#10;    let noise_levels = [0.0, 0.1, 0.3, 0.6, 1.0];&#10;    let mut orders = Vec::new();&#10;    &#10;    for &amp;noise in &amp;noise_levels {&#10;        // Reset simulation for each noise level&#10;        let birds_copy = ensemble::generate(100, 1.0, 0.1, 0.04, &amp;mut rng)&#10;            .expect(&quot;Failed to generate ensemble&quot;);&#10;        &#10;        let mut sim = Simulation::new(birds_copy);&#10;        &#10;        // Equilibrate&#10;        for _ in 0..300 {&#10;            sim.step(0.01, 0.4, noise);&#10;        }&#10;        &#10;        // Measure order parameter&#10;        let order = calculate_order_parameter(sim.birds());&#10;        orders.push(order);&#10;        &#10;        println!(&quot;Noise level: {:.1}, Order parameter: {:.3}&quot;, noise, order);&#10;    }&#10;    &#10;    // Order should generally decrease with increasing noise&#10;    for i in 1..orders.len() {&#10;        if orders[i] &gt; orders[i-1] + 0.05 {&#10;            panic!(&quot;Order increased significantly with noise: {:.3} -&gt; {:.3} at noise {:.1}&quot;, &#10;                orders[i-1], orders[i], noise_levels[i]);&#10;        }&#10;    }&#10;    &#10;    // Very low noise should produce high order&#10;    assert!(orders[0] &gt; 0.5, &quot;Low noise should produce high order: {:.3}&quot;, orders[0]);&#10;    &#10;    // High noise should produce low order&#10;    assert!(orders[orders.len()-1] &lt; 0.3, &#10;        &quot;High noise should produce low order: {:.3}&quot;, orders[orders.len()-1]);&#10;}&#10;&#10;/// Test alignment strength effects&#10;#[test]&#10;fn test_alignment_strength_effects() {&#10;    let mut rng = StdRng::seed_from_u64(789);&#10;    &#10;    let alignment_strengths = [0.0, 0.1, 0.3, 0.7, 1.0];&#10;    let mut orders = Vec::new();&#10;    &#10;    for &amp;strength in &amp;alignment_strengths {&#10;        let birds = ensemble::generate(80, 1.0, 0.1, 0.04, &amp;mut rng)&#10;            .expect(&quot;Failed to generate ensemble&quot;);&#10;        &#10;        let mut sim = Simulation::new(birds);&#10;        &#10;        // Equilibrate with fixed moderate noise&#10;        for _ in 0..400 {&#10;            sim.step(0.01, strength, 0.2);&#10;        }&#10;        &#10;        let order = calculate_order_parameter(sim.birds());&#10;        orders.push(order);&#10;        &#10;        println!(&quot;Alignment strength: {:.1}, Order parameter: {:.3}&quot;, strength, order);&#10;    }&#10;    &#10;    // Order should generally increase with alignment strength&#10;    for i in 1..orders.len() {&#10;        if orders[i] &lt; orders[i-1] - 0.05 {&#10;            println!(&quot;Warning: Order decreased with alignment strength: {:.3} -&gt; {:.3}&quot;, &#10;                orders[i-1], orders[i]);&#10;        }&#10;    }&#10;    &#10;    // Strong alignment should overcome moderate noise&#10;    assert!(orders[orders.len()-1] &gt; 0.2, &#10;        &quot;Strong alignment should produce some order: {:.3}&quot;, orders[orders.len()-1]);&#10;}&#10;&#10;/// Test time step stability&#10;#[test]&#10;fn test_time_step_stability() {&#10;    let mut rng = StdRng::seed_from_u64(999);&#10;    &#10;    let birds = ensemble::generate(30, 1.0, 0.1, 0.06, &amp;mut rng)&#10;        .expect(&quot;Failed to generate ensemble&quot;);&#10;    &#10;    // Test various time steps&#10;    let time_steps = [0.001, 0.01, 0.05, 0.1, 0.2];&#10;    &#10;    for &amp;dt in &amp;time_steps {&#10;        let mut sim = Simulation::new(birds.clone());&#10;        &#10;        // Run simulation and check stability&#10;        for step in 0..50 {&#10;            sim.step(dt, 0.3, 0.1);&#10;            &#10;            // Check for any instabilities&#10;            for (i, bird) in sim.birds().iter().enumerate() {&#10;                let radius = bird.position().norm();&#10;                let speed = bird.velocity().norm();&#10;                &#10;                assert!(!radius.is_nan() &amp;&amp; !radius.is_infinite(), &#10;                    &quot;NaN/Inf radius at step {}, bird {}, dt = {}&quot;, step, i, dt);&#10;                &#10;                assert!(!speed.is_nan() &amp;&amp; !speed.is_infinite(), &#10;                    &quot;NaN/Inf speed at step {}, bird {}, dt = {}&quot;, step, i, dt);&#10;                &#10;                assert!((radius - 1.0).abs() &lt; 0.01, &#10;                    &quot;Large radius deviation at step {}, bird {}, dt = {}: radius = {}&quot;, &#10;                    step, i, dt, radius);&#10;            }&#10;        }&#10;        &#10;        println!(&quot;Time step dt = {:.3} completed successfully&quot;, dt);&#10;    }&#10;}&#10;&#10;/// Test simulation with extreme parameters&#10;#[test]&#10;fn test_extreme_parameters() {&#10;    let mut rng = StdRng::seed_from_u64(1337);&#10;    &#10;    let birds = ensemble::generate(20, 1.0, 0.1, 0.1, &amp;mut rng)&#10;        .expect(&quot;Failed to generate ensemble&quot;);&#10;    &#10;    let mut sim = Simulation::new(birds);&#10;    &#10;    // Test with extreme alignment (should not cause instability)&#10;    for _ in 0..20 {&#10;        sim.step(0.01, 10.0, 0.1);&#10;        &#10;        // Check birds still on sphere&#10;        for bird in sim.birds() {&#10;            let radius = bird.position().norm();&#10;            assert!((radius - 1.0).abs() &lt; 1e-6, &quot;Extreme alignment caused instability&quot;);&#10;        }&#10;    }&#10;    &#10;    // Test with extreme noise (should not cause crashes)&#10;    for _ in 0..20 {&#10;        sim.step(0.01, 0.1, 5.0);&#10;        &#10;        for bird in sim.birds() {&#10;            let radius = bird.position().norm();&#10;            assert!(!radius.is_nan(), &quot;Extreme noise caused NaN&quot;);&#10;            assert!((radius - 1.0).abs() &lt; 1e-6, &quot;Extreme noise caused instability&quot;);&#10;        }&#10;    }&#10;}&#10;&#10;/// Test cluster formation and persistence&#10;#[test]&#10;fn test_cluster_formation() {&#10;    let mut rng = StdRng::seed_from_u64(2024);&#10;    &#10;    // Start with a configuration that should form clusters&#10;    let birds = ensemble::generate(150, 1.0, 0.1, 0.02, &amp;mut rng)&#10;        .expect(&quot;Failed to generate ensemble&quot;);&#10;    &#10;    let mut sim = Simulation::new(birds);&#10;    &#10;    // Run with parameters that promote clustering&#10;    for _ in 0..800 {&#10;        sim.step(0.01, 0.6, 0.15);&#10;    }&#10;    &#10;    // Analyze cluster formation&#10;    let birds = sim.birds();&#10;    let clusters = find_clusters(birds, 0.1); // Birds within 0.1 distance are in same cluster&#10;    &#10;    // Should form multiple clusters (not all birds in one cluster, not all isolated)&#10;    assert!(clusters.len() &gt; 1, &quot;No clustering occurred: only {} clusters&quot;, clusters.len());&#10;    assert!(clusters.len() &lt; birds.len() / 2, &#10;        &quot;Too many small clusters: {} clusters for {} birds&quot;, clusters.len(), birds.len());&#10;    &#10;    // Largest cluster should contain a reasonable fraction of birds&#10;    let largest_cluster_size = clusters.iter().map(|c| c.len()).max().unwrap_or(0);&#10;    let fraction_in_largest = largest_cluster_size as f64 / birds.len() as f64;&#10;    &#10;    assert!(fraction_in_largest &gt; 0.1 &amp;&amp; fraction_in_largest &lt; 0.9, &#10;        &quot;Unrealistic cluster size distribution: largest cluster has {:.1}% of birds&quot;, &#10;        fraction_in_largest * 100.0);&#10;}&#10;&#10;/// Helper function to calculate order parameter&#10;fn calculate_order_parameter(birds: &amp;[Bird]) -&gt; f64 {&#10;    if birds.is_empty() {&#10;        return 0.0;&#10;    }&#10;    &#10;    let mut sum_velocity = Vec3::new(0.0, 0.0, 0.0);&#10;    let mut total_speed = 0.0;&#10;    &#10;    for bird in birds {&#10;        sum_velocity = sum_velocity + *bird.velocity();&#10;        total_speed += bird.velocity().norm();&#10;    }&#10;    &#10;    if total_speed == 0.0 {&#10;        return 0.0;&#10;    }&#10;    &#10;    sum_velocity.norm() / total_speed&#10;}&#10;&#10;/// Helper function to find clusters of nearby birds&#10;fn find_clusters(birds: &amp;[Bird], max_distance: f64) -&gt; Vec&lt;Vec&lt;usize&gt;&gt; {&#10;    let mut visited = vec![false; birds.len()];&#10;    let mut clusters = Vec::new();&#10;    &#10;    for i in 0..birds.len() {&#10;        if visited[i] {&#10;            continue;&#10;        }&#10;        &#10;        let mut cluster = Vec::new();&#10;        let mut stack = vec![i];&#10;        &#10;        while let Some(idx) = stack.pop() {&#10;            if visited[idx] {&#10;                continue;&#10;            }&#10;            &#10;            visited[idx] = true;&#10;            cluster.push(idx);&#10;            &#10;            // Find neighbors&#10;            for j in 0..birds.len() {&#10;                if !visited[j] &amp;&amp; birds[idx].distance_to(&amp;birds[j]) &lt;= max_distance {&#10;                    stack.push(j);&#10;                }&#10;            }&#10;        }&#10;        &#10;        clusters.push(cluster);&#10;    }&#10;    &#10;    clusters&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>