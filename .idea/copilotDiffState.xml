<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/io.rs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/io.rs" />
              <option name="updatedContent" value="//! # IO Module - Data Persistence and Pipeline Management&#10;//!&#10;//! This module provides data persistence functionality for the flocking simulation pipeline.&#10;//! It handles saving and loading of ensemble data, simulation results, and analysis outputs&#10;//! to support the three-stage pipeline:&#10;//!&#10;//! 1. **Ensemble Generation** → Save to `./data/ensemble/`&#10;//! 2. **Simulation Execution** → Save to `./data/simulation/`&#10;//! 3. **Analysis Processing** → Save to `./data/analysis/` (future implementation)&#10;//!&#10;//! All data is stored in the `./data/` directory with organized subdirectories for each&#10;//! pipeline stage.&#10;&#10;pub mod ensemble;&#10;pub mod simulation;&#10;pub mod analysis;&#10;&#10;use std::fs;&#10;use std::path::Path;&#10;&#10;/// Ensures the data directory structure exists&#10;pub fn ensure_data_directories() -&gt; Result&lt;(), std::io::Error&gt; {&#10;    fs::create_dir_all(&quot;./data/ensemble&quot;)?;&#10;    fs::create_dir_all(&quot;./data/simulation&quot;)?;&#10;    fs::create_dir_all(&quot;./data/analysis&quot;)?;&#10;    Ok(())&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/tests/ensemble_test.rs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/tests/ensemble_test.rs" />
              <option name="updatedContent" value="//! Integration tests for ensemble generation and statistical properties&#10;//!&#10;//! These tests verify that ensemble generation produces statistically valid&#10;//! distributions and that the generated configurations are suitable for&#10;//! physical simulations.&#10;&#10;use flocking_lib::{ensemble, vector::Vec3};&#10;use rand::{rngs::StdRng, SeedableRng};&#10;use std::f64::consts::PI;&#10;&#10;/// Test uniform distribution on sphere surface&#10;#[test]&#10;fn test_uniform_sphere_distribution() {&#10;    let mut rng = StdRng::seed_from_u64(42);&#10;    &#10;    // Generate a large ensemble to test statistical properties&#10;    let birds = ensemble::generate(1000, 1.0, 0.1, 0.03, &amp;mut rng)&#10;        .expect(&quot;Failed to generate ensemble&quot;);&#10;    &#10;    // Test that positions are uniformly distributed on sphere&#10;    let mut north_count = 0;&#10;    let mut south_count = 0;&#10;    &#10;    for bird in &amp;birds {&#10;        let pos = bird.position();&#10;        if pos.z &gt; 0.0 {&#10;            north_count += 1;&#10;        } else {&#10;            south_count += 1;&#10;        }&#10;    }&#10;    &#10;    // Should be roughly equal distribution between hemispheres&#10;    let ratio = north_count as f64 / south_count as f64;&#10;    assert!(ratio &gt; 0.8 &amp;&amp; ratio &lt; 1.2, &#10;        &quot;Uneven hemisphere distribution: N={}, S={}, ratio={:.3}&quot;, &#10;        north_count, south_count, ratio);&#10;}&#10;&#10;/// Test velocity distribution properties&#10;#[test]&#10;fn test_velocity_distribution() {&#10;    let mut rng = StdRng::seed_from_u64(123);&#10;    &#10;    let birds = ensemble::generate(500, 1.0, 0.15, 0.05, &amp;mut rng)&#10;        .expect(&quot;Failed to generate ensemble&quot;);&#10;    &#10;    let mut speed_sum = 0.0;&#10;    let mut speed_squared_sum = 0.0;&#10;    &#10;    for bird in &amp;birds {&#10;        let speed = bird.velocity().norm();&#10;        speed_sum += speed;&#10;        speed_squared_sum += speed * speed;&#10;        &#10;        // All speeds should be close to the specified speed&#10;        assert!((speed - 0.15).abs() &lt; 1e-10, &#10;            &quot;Bird speed deviates from expected: {} vs 0.15&quot;, speed);&#10;    }&#10;    &#10;    let mean_speed = speed_sum / birds.len() as f64;&#10;    let variance = speed_squared_sum / birds.len() as f64 - mean_speed * mean_speed;&#10;    &#10;    // Mean should be very close to specified speed&#10;    assert!((mean_speed - 0.15).abs() &lt; 1e-8, &#10;        &quot;Mean speed incorrect: {}&quot;, mean_speed);&#10;    &#10;    // Variance should be very small (all speeds should be identical)&#10;    assert!(variance &lt; 1e-15, &quot;Speed variance too large: {}&quot;, variance);&#10;}&#10;&#10;/// Test that ensemble respects minimum separation constraints&#10;#[test]&#10;fn test_separation_constraints() {&#10;    let mut rng = StdRng::seed_from_u64(456);&#10;    &#10;    let min_sep = 0.1;&#10;    let birds = ensemble::generate(100, 1.0, 0.1, min_sep, &amp;mut rng)&#10;        .expect(&quot;Failed to generate ensemble&quot;);&#10;    &#10;    let mut min_distance = f64::INFINITY;&#10;    let mut violations = 0;&#10;    &#10;    for (i, bird1) in birds.iter().enumerate() {&#10;        for bird2 in birds.iter().skip(i + 1) {&#10;            let distance = bird1.distance_to(bird2);&#10;            min_distance = min_distance.min(distance);&#10;            &#10;            if distance &lt; min_sep - 1e-12 {&#10;                violations += 1;&#10;            }&#10;        }&#10;    }&#10;    &#10;    assert_eq!(violations, 0, &#10;        &quot;Found {} separation violations, minimum distance: {}&quot;, &#10;        violations, min_distance);&#10;    &#10;    assert!(min_distance &gt;= min_sep - 1e-12, &#10;        &quot;Minimum distance {} below threshold {}&quot;, min_distance, min_sep);&#10;}&#10;&#10;/// Test ensemble generation with different sphere radii&#10;#[test]&#10;fn test_different_sphere_radii() {&#10;    let mut rng = StdRng::seed_from_u64(789);&#10;    &#10;    for radius in [0.5, 1.0, 2.0, 5.0] {&#10;        let birds = ensemble::generate(50, radius, 0.1, 0.05, &amp;mut rng)&#10;            .expect(&amp;format!(&quot;Failed to generate ensemble for radius {}&quot;, radius));&#10;        &#10;        // All birds should be on the sphere of the specified radius&#10;        for bird in &amp;birds {&#10;            let actual_radius = bird.position().norm();&#10;            assert!((actual_radius - radius).abs() &lt; 1e-10, &#10;                &quot;Bird not on sphere of radius {}: actual radius = {}&quot;, &#10;                radius, actual_radius);&#10;        }&#10;        &#10;        // Minimum separation should scale with sphere size for surface distance&#10;        let min_surface_sep = 0.05;&#10;        for (i, bird1) in birds.iter().enumerate() {&#10;            for bird2 in birds.iter().skip(i + 1) {&#10;                let distance = bird1.distance_to(bird2);&#10;                assert!(distance &gt;= min_surface_sep - 1e-12, &#10;                    &quot;Surface separation violation on radius {} sphere&quot;, radius);&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;/// Test ensemble generation failure modes&#10;#[test]&#10;fn test_ensemble_generation_limits() {&#10;    let mut rng = StdRng::seed_from_u64(999);&#10;    &#10;    // Test impossible configurations&#10;    &#10;    // Too many birds for the space available&#10;    let result = ensemble::generate(10000, 1.0, 0.1, 0.5, &amp;mut rng);&#10;    // This should either fail or take extremely long - we mainly test it doesn't panic&#10;    &#10;    // Minimum separation larger than sphere diameter&#10;    let result = ensemble::generate(2, 1.0, 0.1, 5.0, &amp;mut rng);&#10;    // Should fail as it's impossible to place 2 birds this far apart on a sphere&#10;    &#10;    // Zero or negative parameters&#10;    let result = ensemble::generate(10, 0.0, 0.1, 0.1, &amp;mut rng);&#10;    // Should fail for zero radius&#10;    &#10;    let result = ensemble::generate(10, 1.0, -0.1, 0.1, &amp;mut rng);&#10;    // Should fail for negative speed&#10;    &#10;    let result = ensemble::generate(10, 1.0, 0.1, -0.1, &amp;mut rng);&#10;    // Should fail for negative separation&#10;}&#10;&#10;/// Test reproducibility with fixed random seeds&#10;#[test]&#10;fn test_ensemble_reproducibility() {&#10;    // Same seed should produce identical ensembles&#10;    let mut rng1 = StdRng::seed_from_u64(12345);&#10;    let mut rng2 = StdRng::seed_from_u64(12345);&#10;    &#10;    let birds1 = ensemble::generate(20, 1.0, 0.1, 0.1, &amp;mut rng1)&#10;        .expect(&quot;Failed to generate first ensemble&quot;);&#10;    &#10;    let birds2 = ensemble::generate(20, 1.0, 0.1, 0.1, &amp;mut rng2)&#10;        .expect(&quot;Failed to generate second ensemble&quot;);&#10;    &#10;    assert_eq!(birds1.len(), birds2.len());&#10;    &#10;    // Positions and velocities should be identical&#10;    for (bird1, bird2) in birds1.iter().zip(birds2.iter()) {&#10;        let pos_diff = (*bird1.position() - *bird2.position()).norm();&#10;        let vel_diff = (*bird1.velocity() - *bird2.velocity()).norm();&#10;        &#10;        assert!(pos_diff &lt; 1e-15, &quot;Position difference: {}&quot;, pos_diff);&#10;        assert!(vel_diff &lt; 1e-15, &quot;Velocity difference: {}&quot;, vel_diff);&#10;    }&#10;}&#10;&#10;/// Test statistical properties of velocity orientations&#10;#[test]&#10;fn test_velocity_orientation_statistics() {&#10;    let mut rng = StdRng::seed_from_u64(2024);&#10;    &#10;    let birds = ensemble::generate(1000, 1.0, 0.1, 0.02, &amp;mut rng)&#10;        .expect(&quot;Failed to generate ensemble&quot;);&#10;    &#10;    // Calculate average velocity direction (should be close to zero for random orientations)&#10;    let mut avg_velocity = Vec3::new(0.0, 0.0, 0.0);&#10;    &#10;    for bird in &amp;birds {&#10;        let normalized_vel = bird.velocity().normalize();&#10;        avg_velocity = avg_velocity + normalized_vel;&#10;    }&#10;    &#10;    avg_velocity = avg_velocity * (1.0 / birds.len() as f64);&#10;    &#10;    // For uniformly random orientations, average should be near zero&#10;    let avg_magnitude = avg_velocity.norm();&#10;    assert!(avg_magnitude &lt; 0.1, &#10;        &quot;Average velocity direction not random enough: magnitude = {}&quot;, avg_magnitude);&#10;}&#10;&#10;/// Test ensemble generation performance&#10;#[test]&#10;fn test_ensemble_generation_performance() {&#10;    let mut rng = StdRng::seed_from_u64(1111);&#10;    &#10;    let start = std::time::Instant::now();&#10;    &#10;    // Generate several ensembles to test performance&#10;    for i in 0..10 {&#10;        let _birds = ensemble::generate(100, 1.0, 0.1, 0.03, &amp;mut rng)&#10;            .expect(&amp;format!(&quot;Failed to generate ensemble {}&quot;, i));&#10;    }&#10;    &#10;    let duration = start.elapsed();&#10;    &#10;    // Should complete reasonably quickly&#10;    assert!(duration.as_secs() &lt; 10, &#10;        &quot;Ensemble generation too slow: took {:.2} seconds&quot;, duration.as_secs_f64());&#10;    &#10;    println!(&quot;Ensemble generation performance: 10 ensembles of 100 birds took {:.3} ms&quot;, &#10;        duration.as_millis());&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/tests/simulation_test.rs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/tests/simulation_test.rs" />
              <option name="updatedContent" value="//! Integration tests for simulation physics and behavior&#10;//!&#10;//! These tests verify that the simulation engine correctly implements&#10;//! the Vicsek model physics and produces expected flocking behaviors.&#10;&#10;use flocking_lib::{bird::Bird, ensemble, simulation::Simulation, vector::Vec3};&#10;use rand::{rngs::StdRng, SeedableRng};&#10;use std::f64::consts::PI;&#10;&#10;/// Test that flocking behavior emerges with appropriate parameters&#10;#[test]&#10;fn test_flocking_emergence() {&#10;    let mut rng = StdRng::seed_from_u64(42);&#10;    &#10;    // Create birds with initially random velocities&#10;    let birds = ensemble::generate(200, 1.0, 0.1, 0.03, &amp;mut rng)&#10;        .expect(&quot;Failed to generate ensemble&quot;);&#10;    &#10;    let mut sim = Simulation::new(birds);&#10;    &#10;    // Measure initial order (should be low due to random velocities)&#10;    let initial_order = calculate_order_parameter(sim.birds());&#10;    &#10;    // Run simulation with strong alignment and low noise&#10;    let alignment_strength = 0.5;&#10;    let noise_strength = 0.05;&#10;    let dt = 0.01;&#10;    &#10;    // Allow time for flocking to emerge&#10;    for _ in 0..500 {&#10;        sim.step(dt, alignment_strength, noise_strength);&#10;    }&#10;    &#10;    let final_order = calculate_order_parameter(sim.birds());&#10;    &#10;    // Order should increase significantly due to flocking&#10;    assert!(final_order &gt; initial_order + 0.1, &#10;        &quot;Flocking did not emerge: initial order = {:.3}, final order = {:.3}&quot;, &#10;        initial_order, final_order);&#10;    &#10;    // Final order should be reasonably high&#10;    assert!(final_order &gt; 0.3, &#10;        &quot;Final order too low: {:.3}&quot;, final_order);&#10;}&#10;&#10;/// Test conservation laws and constraints during simulation&#10;#[test]&#10;fn test_conservation_laws() {&#10;    let mut rng = StdRng::seed_from_u64(123);&#10;    &#10;    let birds = ensemble::generate(50, 1.0, 0.15, 0.05, &amp;mut rng)&#10;        .expect(&quot;Failed to generate ensemble&quot;);&#10;    &#10;    let mut sim = Simulation::new(birds);&#10;    &#10;    // Track various quantities that should be conserved or constrained&#10;    for step in 0..100 {&#10;        sim.step(0.02, 0.3, 0.1);&#10;        &#10;        let birds = sim.birds();&#10;        &#10;        // All birds must remain on sphere surface&#10;        for (i, bird) in birds.iter().enumerate() {&#10;            let radius = bird.position().norm();&#10;            assert!((radius - 1.0).abs() &lt; 1e-8, &#10;                &quot;Step {}, Bird {}: left sphere surface, radius = {:.10}&quot;, &#10;                step, i, radius);&#10;        }&#10;        &#10;        // Bird speeds should be maintained (approximately)&#10;        for (i, bird) in birds.iter().enumerate() {&#10;            let speed = bird.velocity().norm();&#10;            assert!(speed &gt; 0.05 &amp;&amp; speed &lt; 0.3, &#10;                &quot;Step {}, Bird {}: invalid speed = {:.6}&quot;, &#10;                step, i, speed);&#10;        }&#10;        &#10;        // Velocities should be roughly tangent to sphere&#10;        for (i, bird) in birds.iter().enumerate() {&#10;            let pos = bird.position().normalize();&#10;            let vel = bird.velocity().normalize();&#10;            let dot_product = pos.dot(&amp;vel).abs();&#10;            &#10;            // Dot product should be small for tangent vectors&#10;            assert!(dot_product &lt; 0.1, &#10;                &quot;Step {}, Bird {}: velocity not tangent, dot = {:.6}&quot;, &#10;                step, i, dot_product);&#10;        }&#10;    }&#10;}&#10;&#10;/// Test response to different noise levels&#10;#[test]&#10;fn test_noise_response() {&#10;    let mut rng = StdRng::seed_from_u64(456);&#10;    &#10;    let birds = ensemble::generate(100, 1.0, 0.1, 0.04, &amp;mut rng)&#10;        .expect(&quot;Failed to generate ensemble&quot;);&#10;    &#10;    let noise_levels = [0.0, 0.1, 0.3, 0.6, 1.0];&#10;    let mut orders = Vec::new();&#10;    &#10;    for &amp;noise in &amp;noise_levels {&#10;        // Reset simulation for each noise level&#10;        let birds_copy = ensemble::generate(100, 1.0, 0.1, 0.04, &amp;mut rng)&#10;            .expect(&quot;Failed to generate ensemble&quot;);&#10;        &#10;        let mut sim = Simulation::new(birds_copy);&#10;        &#10;        // Equilibrate&#10;        for _ in 0..300 {&#10;            sim.step(0.01, 0.4, noise);&#10;        }&#10;        &#10;        // Measure order parameter&#10;        let order = calculate_order_parameter(sim.birds());&#10;        orders.push(order);&#10;        &#10;        println!(&quot;Noise level: {:.1}, Order parameter: {:.3}&quot;, noise, order);&#10;    }&#10;    &#10;    // Order should generally decrease with increasing noise&#10;    for i in 1..orders.len() {&#10;        if orders[i] &gt; orders[i-1] + 0.05 {&#10;            panic!(&quot;Order increased significantly with noise: {:.3} -&gt; {:.3} at noise {:.1}&quot;, &#10;                orders[i-1], orders[i], noise_levels[i]);&#10;        }&#10;    }&#10;    &#10;    // Very low noise should produce high order&#10;    assert!(orders[0] &gt; 0.5, &quot;Low noise should produce high order: {:.3}&quot;, orders[0]);&#10;    &#10;    // High noise should produce low order&#10;    assert!(orders[orders.len()-1] &lt; 0.3, &#10;        &quot;High noise should produce low order: {:.3}&quot;, orders[orders.len()-1]);&#10;}&#10;&#10;/// Test alignment strength effects&#10;#[test]&#10;fn test_alignment_strength_effects() {&#10;    let mut rng = StdRng::seed_from_u64(789);&#10;    &#10;    let alignment_strengths = [0.0, 0.1, 0.3, 0.7, 1.0];&#10;    let mut orders = Vec::new();&#10;    &#10;    for &amp;strength in &amp;alignment_strengths {&#10;        let birds = ensemble::generate(80, 1.0, 0.1, 0.04, &amp;mut rng)&#10;            .expect(&quot;Failed to generate ensemble&quot;);&#10;        &#10;        let mut sim = Simulation::new(birds);&#10;        &#10;        // Equilibrate with fixed moderate noise&#10;        for _ in 0..400 {&#10;            sim.step(0.01, strength, 0.2);&#10;        }&#10;        &#10;        let order = calculate_order_parameter(sim.birds());&#10;        orders.push(order);&#10;        &#10;        println!(&quot;Alignment strength: {:.1}, Order parameter: {:.3}&quot;, strength, order);&#10;    }&#10;    &#10;    // Order should generally increase with alignment strength&#10;    for i in 1..orders.len() {&#10;        if orders[i] &lt; orders[i-1] - 0.05 {&#10;            println!(&quot;Warning: Order decreased with alignment strength: {:.3} -&gt; {:.3}&quot;, &#10;                orders[i-1], orders[i]);&#10;        }&#10;    }&#10;    &#10;    // Strong alignment should overcome moderate noise&#10;    assert!(orders[orders.len()-1] &gt; 0.2, &#10;        &quot;Strong alignment should produce some order: {:.3}&quot;, orders[orders.len()-1]);&#10;}&#10;&#10;/// Test time step stability&#10;#[test]&#10;fn test_time_step_stability() {&#10;    let mut rng = StdRng::seed_from_u64(999);&#10;    &#10;    let birds = ensemble::generate(30, 1.0, 0.1, 0.06, &amp;mut rng)&#10;        .expect(&quot;Failed to generate ensemble&quot;);&#10;    &#10;    // Test various time steps&#10;    let time_steps = [0.001, 0.01, 0.05, 0.1, 0.2];&#10;    &#10;    for &amp;dt in &amp;time_steps {&#10;        let mut sim = Simulation::new(birds.clone());&#10;        &#10;        // Run simulation and check stability&#10;        for step in 0..50 {&#10;            sim.step(dt, 0.3, 0.1);&#10;            &#10;            // Check for any instabilities&#10;            for (i, bird) in sim.birds().iter().enumerate() {&#10;                let radius = bird.position().norm();&#10;                let speed = bird.velocity().norm();&#10;                &#10;                assert!(!radius.is_nan() &amp;&amp; !radius.is_infinite(), &#10;                    &quot;NaN/Inf radius at step {}, bird {}, dt = {}&quot;, step, i, dt);&#10;                &#10;                assert!(!speed.is_nan() &amp;&amp; !speed.is_infinite(), &#10;                    &quot;NaN/Inf speed at step {}, bird {}, dt = {}&quot;, step, i, dt);&#10;                &#10;                assert!((radius - 1.0).abs() &lt; 0.01, &#10;                    &quot;Large radius deviation at step {}, bird {}, dt = {}: radius = {}&quot;, &#10;                    step, i, dt, radius);&#10;            }&#10;        }&#10;        &#10;        println!(&quot;Time step dt = {:.3} completed successfully&quot;, dt);&#10;    }&#10;}&#10;&#10;/// Test simulation with extreme parameters&#10;#[test]&#10;fn test_extreme_parameters() {&#10;    let mut rng = StdRng::seed_from_u64(1337);&#10;    &#10;    let birds = ensemble::generate(20, 1.0, 0.1, 0.1, &amp;mut rng)&#10;        .expect(&quot;Failed to generate ensemble&quot;);&#10;    &#10;    let mut sim = Simulation::new(birds);&#10;    &#10;    // Test with extreme alignment (should not cause instability)&#10;    for _ in 0..20 {&#10;        sim.step(0.01, 10.0, 0.1);&#10;        &#10;        // Check birds still on sphere&#10;        for bird in sim.birds() {&#10;            let radius = bird.position().norm();&#10;            assert!((radius - 1.0).abs() &lt; 1e-6, &quot;Extreme alignment caused instability&quot;);&#10;        }&#10;    }&#10;    &#10;    // Test with extreme noise (should not cause crashes)&#10;    for _ in 0..20 {&#10;        sim.step(0.01, 0.1, 5.0);&#10;        &#10;        for bird in sim.birds() {&#10;            let radius = bird.position().norm();&#10;            assert!(!radius.is_nan(), &quot;Extreme noise caused NaN&quot;);&#10;            assert!((radius - 1.0).abs() &lt; 1e-6, &quot;Extreme noise caused instability&quot;);&#10;        }&#10;    }&#10;}&#10;&#10;/// Test cluster formation and persistence&#10;#[test]&#10;fn test_cluster_formation() {&#10;    let mut rng = StdRng::seed_from_u64(2024);&#10;    &#10;    // Start with a configuration that should form clusters&#10;    let birds = ensemble::generate(150, 1.0, 0.1, 0.02, &amp;mut rng)&#10;        .expect(&quot;Failed to generate ensemble&quot;);&#10;    &#10;    let mut sim = Simulation::new(birds);&#10;    &#10;    // Run with parameters that promote clustering&#10;    for _ in 0..800 {&#10;        sim.step(0.01, 0.6, 0.15);&#10;    }&#10;    &#10;    // Analyze cluster formation&#10;    let birds = sim.birds();&#10;    let clusters = find_clusters(birds, 0.1); // Birds within 0.1 distance are in same cluster&#10;    &#10;    // Should form multiple clusters (not all birds in one cluster, not all isolated)&#10;    assert!(clusters.len() &gt; 1, &quot;No clustering occurred: only {} clusters&quot;, clusters.len());&#10;    assert!(clusters.len() &lt; birds.len() / 2, &#10;        &quot;Too many small clusters: {} clusters for {} birds&quot;, clusters.len(), birds.len());&#10;    &#10;    // Largest cluster should contain a reasonable fraction of birds&#10;    let largest_cluster_size = clusters.iter().map(|c| c.len()).max().unwrap_or(0);&#10;    let fraction_in_largest = largest_cluster_size as f64 / birds.len() as f64;&#10;    &#10;    assert!(fraction_in_largest &gt; 0.1 &amp;&amp; fraction_in_largest &lt; 0.9, &#10;        &quot;Unrealistic cluster size distribution: largest cluster has {:.1}% of birds&quot;, &#10;        fraction_in_largest * 100.0);&#10;}&#10;&#10;/// Helper function to calculate order parameter&#10;fn calculate_order_parameter(birds: &amp;[Bird]) -&gt; f64 {&#10;    if birds.is_empty() {&#10;        return 0.0;&#10;    }&#10;    &#10;    let mut sum_velocity = Vec3::new(0.0, 0.0, 0.0);&#10;    let mut total_speed = 0.0;&#10;    &#10;    for bird in birds {&#10;        sum_velocity = sum_velocity + *bird.velocity();&#10;        total_speed += bird.velocity().norm();&#10;    }&#10;    &#10;    if total_speed == 0.0 {&#10;        return 0.0;&#10;    }&#10;    &#10;    sum_velocity.norm() / total_speed&#10;}&#10;&#10;/// Helper function to find clusters of nearby birds&#10;fn find_clusters(birds: &amp;[Bird], max_distance: f64) -&gt; Vec&lt;Vec&lt;usize&gt;&gt; {&#10;    let mut visited = vec![false; birds.len()];&#10;    let mut clusters = Vec::new();&#10;    &#10;    for i in 0..birds.len() {&#10;        if visited[i] {&#10;            continue;&#10;        }&#10;        &#10;        let mut cluster = Vec::new();&#10;        let mut stack = vec![i];&#10;        &#10;        while let Some(idx) = stack.pop() {&#10;            if visited[idx] {&#10;                continue;&#10;            }&#10;            &#10;            visited[idx] = true;&#10;            cluster.push(idx);&#10;            &#10;            // Find neighbors&#10;            for j in 0..birds.len() {&#10;                if !visited[j] &amp;&amp; birds[idx].distance_to(&amp;birds[j]) &lt;= max_distance {&#10;                    stack.push(j);&#10;                }&#10;            }&#10;        }&#10;        &#10;        clusters.push(cluster);&#10;    }&#10;    &#10;    clusters&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>